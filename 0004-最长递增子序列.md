文档名称: `0004-最长递增子序列.md`

### 1\. 原题呈现

**链接:** [https://leetcode.cn/problems/longest-increasing-subsequence/](https://leetcode.cn/problems/longest-increasing-subsequence/)

**题目描述:**

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

  * **输入：** `nums = [10,9,2,5,3,7,101,18]`
  * **输出：** 4
  * **解释：** 最长递增子序列是 `[2,3,7,101]`，因此长度为 4 。

**示例 2：**

  * **输入：** `nums = [0,1,0,3,2,3]`
  * **输出：** 4

**示例 3：**

  * **输入：** `nums = [7,7,7,7,7,7,7]`
  * **输出：** 1

### 2\. 你的题解

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 先处理一下边界情况吧
        if(nums == null || nums.length == 0){
            return 0;
        }

        // 引入一个变量来存储最长严格递增子序列的长度
        int Maxlength = 1;

        int n = nums.length;

        // 创建 dp 表单
        // dp 表单中的元素代表着每个元素可以搭建的最高长度
        int[] dp = new int[n];

        // 对 dp 表单进行初始化，自己就是一层，初始化就为1
        Arrays.fill(dp,1);

        for(int i = 1; i < n; i++){
             for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
             }
             Maxlength = Math.max(dp[i],Maxlength);
        }
        return Maxlength;
    }
}
```

### 3\. 时空复杂度分析

  * **时间复杂度: $O(n^2)$**

      * 分析：代码的核心是一个嵌套的双重循环。外层循环遍历数组从第1个元素到最后一个（`n-1`次），内层循环遍历从第0个元素到`i-1`。总体来看，这是一个典型的二次方时间复杂度的模式。

  * **空间复杂度: $O(n)$**

      * 分析：算法使用了一个与输入数组 `nums` 等长的 `dp` 数组来存储状态。因此，空间开销与输入数组的长度 `n` 成正比。

### 4\. 你所犯的错误点

（原文复现）
犯错的点的话，大致就是在初始化dp数组，调用Arrays.fill()方法时，方法写错了，写成 Array.fill()了，少写了一个 s ,还有就是后面的形参列表也写错了，写成 nums 数组了，应该 dp 数组的

然后在整体思路上大体上是没什么问题的，关于最关键的部分，也就是更新 dp 表单的时候也算是能进行一个解释了吧，i 作为挑战者，一次对于 j 的每一位前辈进行挑战，挑战无非是两种结果，第一种结果是 dp[i] \> dp[j]，那么 dp[i] 就可以站在前辈的肩膀上，也就是 dp[j]+1，和原来的擂主 dp[i] 进行比较，取最大值嘛

### 5\. 专属重构行动

**重构行动一：建立个人“代码组件”库**

  * **行动清单：**

      * 打开你的笔记文件 `Java_Snippets.md`，添加以下组件：

    <!-- end list -->

    ```java
    // 组件一：Java数组初始化 (API纠错)
    // 目的：固化对 `Arrays` 工具类及其方法（如 `fill`）的正确调用。

    // 1. 导入包 (如果在独立的.java文件中)
    import java.util.Arrays;

    // 2. 声明和创建数组
    int n = 10;
    int[] dp = new int[n];

    // 3. 正确调用 `Arrays.fill()` 方法
    // 类名是 `Arrays` (带s)，表示这是一个工具类。
    // 第一个参数是要填充的数组名，第二个参数是要填充的值。
    Arrays.fill(dp, 1); // 将dp数组的所有元素设置为1

    // 错误示范1: Arrays 写成 Array -> 编译错误，找不到此类
    // Array.fill(dp, 1); 

    // 错误示范2: 填充了错误的数组 -> 逻辑错误
    // Arrays.fill(nums, 1); 
    ```

**重构行动二：更新“提交前自检清单 (Pre-commit Checklist)”**

  * **你的清单更新如下：**
    1.  **API调用：** 所有标准库的静态方法调用（如 `Arrays.fill`, `Math.max`），类名是否拼写正确？参数是否传递正确？
    2.  **DP状态更新逻辑：** 我能用清晰的语言（比如你提到的“挑战者”和“前辈”）解释 `dp` 表的更新逻辑吗？如果不能，说明理解还不够深刻。
    3.  **最终值来源：** 最终的 `return` 值是从哪里来的？是 `dp` 表的最后一个元素，还是遍历过程中维护的一个全局变量（如此题中的 `Maxlength`）？

### 6\. 其他解法探索

**1. 贪心 + 二分查找 (最优解法)**

  * **思路:** 这是解决此问题的最优解，能将时间复杂度优化到 $O(n \\log n)$。我们维护一个数组 `tails`，其中 `tails[i]` 存储所有长度为 `i+1` 的递增子序列中，结尾数字最小的那一个。
      * 遍历 `nums` 数组，对于每个数字 `num`：
          * 如果 `num` 大于 `tails` 数组中所有的元素，说明可以构成一个更长的递增子序列，我们将 `num` 添加到 `tails` 数组末尾。
          * 否则，我们在 `tails` 数组中通过**二分查找**，找到第一个大于等于 `num` 的元素，并用 `num` 替换掉它。这样做是为了让未来有更多的数字能接在这个子序列后面（因为结尾数字越小，越容易增长）。
  * **时间复杂度:** $O(n \\log n)$ (遍历数组 `n` 次，每次在 `tails` 数组中进行一次二分查找 $\\log n$)
  * **空间复杂度:** $O(n)$ (最坏情况下，`tails` 数组的长度与 `nums` 相同)

**2. 回溯法 (暴力解法)**

  * **思路:** 我们可以通过递归（回溯）来找出所有的递增子序列，然后找到其中最长的一个。
  * **实现:** 设计一个递归函数 `dfs(index, current_subsequence)`，表示从 `nums[index]` 开始，尝试将其加入 `current_subsequence` 并继续向后搜索。
  * **时间复杂度:** $O(2^n)$ (对于每个元素，我们都有“选”或“不选”两种选择，会导致指数级的时间复杂度，会超时)
  * **空间复杂度:** $O(n)$ (递归栈的深度)
  * **价值:** 了解这个解法有助于理解为什么需要用动态规划来避免重复计算。
