文档名称: `0005-最长连续递增序列.md`

### 1\. 原题呈现

**链接:** [https://leetcode.cn/problems/longest-continuous-increasing-subsequence/](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

**题目描述:**

给定一个未经排序的整数数组，找到最长且 **连续** 递增的子序列，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]`，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

**示例 1：**

  * **输入：** `nums = [1,3,5,4,7]`
  * **输出：** 3
  * **解释：** 最长连续递增序列是 `[1,3,5]`，长度为3。尽管 `[1,3,5,7]` 也是升序的子序列, 但它不是连续的，因为 `5` 和 `7` 在原数组里被 `4` 隔开了。

**示例 2：**

  * **输入：** `nums = [2,2,2,2,2]`
  * **输出：** 1
  * **解释：** 最长连续递增序列是 `[2]`，长度为1。

### 2\. 你的题解

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        // 最关键的提醒是肯定是下面这段话：
        // 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定
        // 如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] 
        // 那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列

        // 还是先处理一下边界情况吧，先开始
        if(nums == null || nums.length == 0){
            return 0;
        }

        int max = 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);

        for(int i = 1; i < nums.length; i++){

                if (nums[i] > nums[i - 1]) {
                    // 那么以它结尾的连续序列，就是以前一个结尾的序列长度+1
                    dp[i] = dp[i - 1] + 1;
                }
            max = Math.max(dp[i],max);
        }
        return max;
    }
}
```

### 3\. 时空复杂度分析

  * **时间复杂度: $O(n)$**

      * 分析：代码的核心是一个单层循环，从数组的第二个元素遍历到末尾，总共执行 `n-1` 次。循环体内部的操作都是常数时间，因此整体时间复杂度为线性级别。

  * **空间复杂度: $O(n)$**

      * 分析：算法使用了一个与输入数组 `nums` 等长的 `dp` 数组来存储状态，因此空间开销与输入数组的长度 `n` 成正比。

### 4\. 你所犯的错误点

（原文复现）
犯错的点我觉得是思路上的错误，最开始是试图从头向后以及从尾向前进行暴力穷举，然后取最大值，但这其实并不能应对所有的情况，因为最长连续的子序列可能存在于中间位置；然后觉得LIS思路是可以的，然后去尝试，发现依然是无法面对一些情况，因为LIS应对的是非连续性的问题，而题目需要的是连续，虽然试图采用了else来使dp[i]清零，但是依然是非连续

### 5\. 专属重构行动

**重构行动一：建立个人“代码组件”库**

  * **行动清单：**

      * 打开你的笔记文件 `Java_Snippets.md`，添加以下组件：

    <!-- end list -->

    ```java
    // 组件一：问题模式识别：连续 vs. 子序列 (逻辑组件)
    // 目的：建立对问题关键字的敏感度，从根本上避免选择错误的算法模型。

    /*
     * 审题关键点：
     * * 1. 如果题目要求 “连续” / “子数组” (Continuous / Subarray):
     * - 特点：元素必须紧挨着。
     * - 状态依赖：通常，位置 `i` 的状态只与 `i-1` 相关。
     * - 常用解法：O(n) 的一次遍历（贪心思想或简化DP）。
     * - 例子：最长连续递增序列、最大子数组和。
     *
     * 2. 如果题目要求 “子序列” (Subsequence):
     * - 特点：元素可以跳着选，但相对顺序不变。
     * - 状态依赖：通常，位置 `i` 的状态与 `0` 到 `i-1` 的所有历史状态都可能相关。
     * - 常用解法：O(n^2) 的动态规划，或更优化的 O(n log n) 解法。
     * - 例子：最长递增子序列 (LIS)、最长公共子序列 (LCS)。
     */
    ```

**重构行动二：更新“提交前自检清单 (Pre-commit Checklist)”**

  * **你的清单更新如下：**
    1.  **模式识别：** 题目要求的是 **“连续”** 还是 **“子序列”**？这个问题的回答将从根本上决定你的算法选择，是清单的第一项！
    2.  **暴力解法勘误：** 我最初的暴力/朴素思路，是否遗漏了某些情况（比如你提到的“中间位置”）？
    3.  **算法“降维”：** 我是否正在用一个为“子序列”设计的复杂算法（如 $O(n^2)$ LIS DP）来解决一个“连续”问题？如果是，思考如何利用“连续”的特性（只依赖前一个状态）来简化它，进行“降维打击”。

### 6\. 其他解法探索

**1. 空间优化解法 (最优解)**

  * **思路:** 你的解法使用了 $O(n)$ 的 `dp` 数组，但仔细观察可以发现，在计算 `dp[i]` 时，我们唯一需要的信息就是 `dp[i-1]` 的值。我们根本不关心 `dp[i-2]`, `dp[i-3]` 等更早的历史状态。因此，存储整个 `dp` 数组是冗余的。我们可以用一个单独的变量（比如 `currentLength`）来记录上一步的结果即可。
  * **实现:** 这正是我们之前讨论过的“一次遍历”或“贪心”解法。它将空间复杂度从 $O(n)$ 优化到了 $O(1)$。
  * **时间复杂度:** $O(n)$
  * **空间复杂度:** $O(1)$

**2. 你的两种错误思路 (作为对照)**

  * **思路一：两端指针法**

      * **过程:** 从头向后遍历一次，从尾向前遍历一次，取最大值。
      * **缺陷:** 完全忽略了序列可能出现在数组中间的情况。

  * **思路二：LIS的DP解法**

      * **过程:** 使用 $O(n^2)$ 的双重循环，让 `dp[i]` 依赖于 `0` 到 `i-1` 的所有状态。
      * **缺陷:** 这是为“不连续”问题设计的“牛刀”，用它来解本题属于“杀鸡用牛刀”，不仅复杂度更高，而且逻辑上不匹配，强行修改（如用`else`重置）也容易出错。
