文档名称: `583-两个字符串的删除操作-最终版.md`

### 1\. 原题呈现

**链接:** [https://leetcode.cn/problems/delete-operation-for-two-strings/](https://leetcode.cn/problems/delete-operation-for-two-strings/)

**题目描述:**

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

**示例 1：**

  * **输入:** `word1 = "sea"`, `word2 = "eat"`
  * **输出:** 2
  * **解释:** 第一步将 "sea" 变为 "ea" ，第二步将 "eat" 变为 "ea"

**示例 2：**

  * **输入:** `word1 = "leetcode"`, `word2 = "etco"`
  * **输出:** 4

### 2\. 你的题解

```java
class Solution {
    public int minDistance(String word1, String word2) {
        // 看样子是问删除的字符数，实际上求的是元素的最大公共子序列
        // 让元素的长度 - 最长公共子序列的长度 就是删除操作需要的次数
        // 所以其实还是求最大公共子序列的问题

        // 处理边界情况
        if(word1.length() == 0 || word2.length() == 0 || word1 == null || word2 == null){
            return 0;
        }

        // 不同的是还需要处理一下，两个字符串相同的情况
        // 如果内容完全相同，不需要任何删除
        if (word1.equals(word2)) { // 使用 .equals() 进行内容比较！
            return 0;
        }

        // 下面基本重复求最大公共子序列的操作就行了
        int m = word1.length();
        int n = word2.length();

        // 创建 dp 表单
        int [][] dp = new int[m+1][n+1];

        // 填充 dp 表单
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        // 删除操作的次数，真正的计算公式是 m + n - 2 * LCS
        
        // 计算 word1 需要删除多少字符才能变成 LCS？
        // word1 的原始长度是 len1
        // LCS 的长度是 lcs
        // LCS 本身就是 word1 的一部分，这 lcs 个字符是我们需要保留的
        // 那么需要删除的，自然就是剩下的那些字符
        // 所以，word1 的删除次数 = len1 - lcs

         int LCS = dp[m][n];
         return m + n - 2 * LCS;
    }
}
```

### 3\. 时空复杂度分析

  * **时间复杂度: $O(m \\times n)$**

      * 分析：核心算法是填充一个 `m x n` 的二维 `dp` 矩阵，其中 `m` 和 `n` 分别是两个字符串的长度。这需要一个双重循环，因此时间复杂度与两个字符串长度的乘积成正比。

  * **空间复杂度: $O(m \\times n)$**

      * 分析：算法需要一个 `(m+1) x (n+1)` 大小的二维数组 `dp` 来存储子问题的解，因此空间复杂度与 `m` 和 `n` 的乘积成正比。

### 4\. 你所犯的错误点

（原文复现）
我所犯错的点是对于最终删除操作的公式计算的错误，原以为删除操作的次数 = LCS 的长度，但实际上考虑到 删除的次数 应该是 字符串的长度 - 最长公共子序列的长度，我最初的注释还写对了hhh，还有一个问题就是字符串的比较，也就是 == 和 equals 方法的混淆

### 5\. 专属重构行动

**重构行动一：建立个人“代码组件”库**

  * **行动清单：**

      * 打开你的笔记文件 `Java_Snippets.md`，添加以下两个组件：

    <!-- end list -->

    ```java
    // 组件一：LCS 问题转化公式 (逻辑组件)
    // 目的：固化“LCS变种问题”的思考范式，避免混淆“目标”与“成本”。

    /*
     * 问题：计算将 word1 和 word2 变为相等所需的最少删除次数。
     * 转化思考过程：
     * 1. 最终目标是什么？ -> 一个公共子序列。
     * 2. 什么样的公共子序列能让成本(删除次数)最小？ -> 最长的公共子序列 (LCS)。
     * 3. word1 的成本是多少？ -> (word1 的总长度) - (需要保留的长度) = len1 - lcs
     * 4. word2 的成本是多少？ -> (word2 的总长度) - (需要保留的长度) = len2 - lcs
     * 5. 总成本是多少？ -> (len1 - lcs) + (len2 - lcs) = len1 + len2 - 2 * lcs
     */
    int len1 = word1.length();
    int len2 = word2.length();
    int lcs = dp[m][n]; // 假设 lcs 已通过 DP 计算得出
    int minDeletions = len1 + len2 - 2 * lcs;
    ```

    ```java
    // 组件二：Java 字符串内容比较
    // 目的：杜绝使用 `==` 进行字符串内容比较的错误。

    String str1 = new String("你好");
    String str2 = new String("你好");

    // 错误的方式：`==` 比较的是两个对象的内存地址。
    // str1 和 str2 是两个不同的对象，所以地址不同，结果为 false。
    boolean isSameObject = (str1 == str2); // false

    // 正确的方式：`.equals()` 比较的是两个字符串的实际内容。
    // str1 和 str2 的内容都是 "你好"，所以结果为 true。
    boolean isSameContent = str1.equals(str2); // true
    ```

**重构行动二：更新“提交前自检清单 (Pre-commit Checklist)”**

  * **你的清单更新如下：**
    1.  **最终值转化：** 我计算出的子问题解（如 LCS 长度）是否已根据题意，正确转化成了最终答案（如 删除次数）？
    2.  **字符串比较：** 代码中所有字符串的**内容**比较，是否都使用了 `.equals()` 方法，而不是 `==`？
    3.  **括号 `()` 检查：** 所有方法调用（如 `.length()`）都带了括号吗？
    4.  **`return` 语句检查：** 返回的是否是代表最终解的变量？

### 6\. 其他解法探索

**1. 动态规划 + 空间优化 (最优解法)**

  * **思路:** 与上一题类似，计算 `dp` 矩阵的第 `i` 行时，我们只用到了第 `i-1` 行的数据。因此，可以利用**滚动数组**的思想，使用一个一维数组来代替二维矩阵，将空间复杂度显著优化。
  * **时间复杂度:** $O(m \\times n)$
  * **空间复杂度:** $O(\\min(m, n))$

**2. 递归 + 备忘录 (自顶向下)**

  * **思路:** 动态规划的另一种写法。直接根据问题的递归定义编写函数，并使用一个二维数组（备忘录）来缓存计算过的子问题的结果，以避免重复计算。其核心思想与自底向上的DP完全相同。
  * **时间复杂度:** $O(m \\times n)$
  * **空间复杂度:** $O(m \\times n)$

**3. 编辑距离思路**

  * **思路:** 这个问题可以看作是经典的“编辑距离”（LeetCode 72）问题的一个简化版。在标准的编辑距离中，允许“插入”、“删除”、“替换”三种操作。而本题只允许“插入”和“删除”（对一个字符串的删除等价于对另一个字符串的插入）。我们可以定义 `dp[i][j]` 为 `word1` 的前 `i` 个字符和 `word2` 的前 `j` 个字符匹配所需的最小删除次数，然后推导状态转移方程。最终 `dp[m][n]` 就是答案。这种思路更直接，但最终的DP方程与LCS转化法是等价的。
