文档名称: `1143-最长公共子序列-最终版.md`

### 1\. 原题呈现

**链接:** [https://leetcode.cn/problems/longest-common-subsequence/](https://leetcode.cn/problems/longest-common-subsequence/)

**题目描述:**

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 0 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

  * 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

  * **输入：** `text1 = "abcde", text2 = "ace"`
  * **输出：** 3
  * **解释：** 最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**

  * **输入：** `text1 = "abc", text2 = "abc"`
  * **输出：** 3
  * **解释：** 最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**

  * **输入：** `text1 = "abc", text2 = "def"`
  * **输出：** 0
  * **解释：** 两个字符串没有公共子序列，返回 0 。

### 2\. 你的题解

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        // 首先对于题目进行一个分析，是需要找到相对位置不变的非连续的子序列
        // 说明如果遇到非连续的元素不等的情况下，dp表单是不需要进行清零操作的
        // 在dp[i-1][j]或者dp[i][j-1]当中选择大的那一个就好
        // 最后返回的内容是最长公共子序列的长度,不是具体的最长公共子序列
        // 那么最后输出的内容是 dp[m][n] 的值即可

        // 边界操作
        if(text1 == null || text2 == null || text1.length() == 0 || text2.length() == 0){
            return 0;
        }

        int m = text1.length();
        int n = text2.length();

        // 创建 dp 表单,是二维数组,因为是要取两个字符串的交集嘛
        int[][] dp = new int[m+1][n+1];

        // 填充 dp 表单
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                // 下面就是两种情况的讨论
                // 首先第一种情况是元素相等,如果元素相等的话,在 dp[i-1][j-1] 的基础上 +1 就好
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                // 然后是第二种情况,如果元素不想等的话,在dp[i-1][j]和dp[i][j-1]当中选择大的那个
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        // 最后 return dp[m][n] 的值就好
        // dp[m][n] 的值就是最长公共子序列的值
        return dp[m][n];
    }
}
```

### 3\. 时空复杂度分析

  * **时间复杂度: $O(m \\times n)$**

      * 分析：代码核心是填充 `dp` 矩阵的双重循环。外层循环执行 `m` 次，内层循环执行 `n` 次。循环体内部的操作均为 $O(1)$，因此总时间复杂度为 $O(m \\times n)$。

  * **空间复杂度: $O(m \\times n)$**

      * 分析：算法创建了一个 `(m+1) x (n+1)` 大小的二维数组 `dp`，这是主要的内存开销，因此空间复杂度与 `m` 和 `n` 的乘积成正比。

### 4\. 你所犯的错误点

（原文复现）
第一个是在处理边界情况的时候， text.length() 没有添加()，忘记这是字符串了，字符串获取长度是需要加括号的嘛，第二个是在创建 dp 数组的时候使用的 == ，不是 =;第三个是在获取字符串的单个字母的时候，也就是 charAt() 方法时，忘记如何使用这个方法了；第四个是在 最后的返回值时，返回的是 dp[i][j]，实际应该返回的是 dp[m][n]，m和n是全局的，但是 i 和 j 是 for 循环内部使用的

### 5\. 专属重构行动

**重构行动一：建立个人“代码组件”库**

  * **行动清单：**

      * 打开你的笔记文件 `Java_Snippets.md`，添加以下四个组件：

    <!-- end list -->

    ```java
    // 组件一：字符串长度获取
    // 目的：修正对 String.length() 方法的调用遗忘。
    String s = "示例字符串";
    int len = s.length(); // 正确：字符串长度是一个方法调用，需要括号()。

    // 与数组长度对比（数组长度是属性，无括号）。
    int[] arr = {1, 2, 3};
    int arrLen = arr.length; // 正确：数组长度是属性。
    ```

    ```java
    // 组件二：赋值 与 比较
    // 目的：修正将赋值运算符(=)与比较运算符(==)混淆的错误。
    int myVar;

    // 赋值 (=)：将右侧的值，放入左侧的变量中。
    myVar = 10; 

    // 比较 (==)：判断两侧的值是否相等，返回布尔值(true/false)。
    if (myVar == 10) {
        // 这段代码会执行。
    }
    ```

    ```java
    // 组件三：获取字符串中的指定字符
    // 目的：固化对 String.charAt() 方法的记忆。
    String text = "abcde";

    // 获取指定“零基索引”位置的字符。
    char firstChar = text.charAt(0); // 结果是 'a'
    char thirdChar = text.charAt(2); // 结果是 'c'
    ```

    ```java
    // 组件四：动态规划的最终结果返回
    // 目的：修正返回循环内变量，而非最终结果的错误。
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];

    // ... 此处省略填充dp矩阵的双重for循环 ...
    // 循环使用临时变量 'i' 和 'j'。

    // 循环结束后，最终结果存储在代表两个字符串完整长度的坐标上。
    return dp[m][n]; // 正确：使用全局维度变量 m 和 n。
    ```

**重构行动二：更新“提交前自检清单 (Pre-commit Checklist)”**

  * **你的清单：**
    1.  **括号 `()` 检查：** 所有方法调用（如 `.length()`, `.charAt()`) 都带了括号吗？
    2.  **等号 `=` 检查：** 所有赋值语句都用的是 `=` 吗？所有条件判断都用的是 `==` 吗？
    3.  **API 检查：** `charAt(i-1)` 这样的索引操作，是否正确对应了字符串字符？
    4.  **`return` 语句检查：** 返回的是否是代表最终解的变量（如 `dp[m][n]`），而不是循环中的临时变量？

### 6\. 其他解法探索

**1. 动态规划 + 空间优化 (最优解法)**

  * **思路:** 计算 `dp` 矩阵的第 `i` 行时，只用到了第 `i-1` 行的数据。因此，无需存储整个矩阵。我们可以使用一个一维数组来“滚动”计算，将空间复杂度从 $O(m \\times n)$ 降至 $O(\\min(m, n))$。
  * **时间复杂度:** $O(m \\times n)$
  * **空间复杂度:** $O(\\min(m, n))$

**2. 递归 + 备忘录 (自顶向下)**

  * **思路:** 将问题的递归关系直接翻译成代码，并用一个二维数组 `memo` 来缓存已计算过的子问题的结果，避免重复计算。这种写法有时更贴近人类的直觉思考方式。
  * **时间复杂度:** $O(m \\times n)$
  * **空间复杂度:** $O(m \\times n)$ (用于备忘录和递归调用栈)

**3. 暴力递归 (用于理解DP的必要性)**

  * **思路:** 不使用备忘录，纯粹地进行递归调用。这会导致对同一个子问题的指数级重复计算。
  * **时间复杂度:** $O(2^{\\max(m,n)})$，在当前题目数据范围下会超时。
  * **空间复杂度:** $O(\\max(m,n))$ (递归栈的深度)
